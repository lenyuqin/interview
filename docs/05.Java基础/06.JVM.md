---
title: JVM
date: 2021-04-14 14:18:32
permalink: /pages/5cc2fd/
categories:
  - Java基础
tags:
  - 
---



![jv.png](https://i.loli.net/2019/09/10/HsJXU8S4oVtCTM7.png)



![在这里插入图片描述](https://img.xiaoyou66.com/2021/03/23/3c6944d4abc54.png)



简单说一下每个部分是干嘛的吧

- **程序计数器** 用于记录程序执行的位置（字节码解释器可以改变这个来选取下一条执行的指令）
- **虚拟机栈** 描述的是java方法执行的内存模型，每个方法执行都会创建一个**栈帧**，栈帧包含局部变量表、操作数栈、动态连接、方法出口等。
- **本地方法栈** 本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一，本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现StackOverFlowError 和 OutOfMemoryError 两种错误。
- **堆** Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**
- **方法区** 与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
- **元空间** jdk1.8之后，就把方法区放到元空间了，元空间直接放到本地内存了（这样我们就不用担心之前永久代内存溢出的问题，只要本地内存足够，就不会出现java.lang.OutOfMemoryError: PermGen space的错误）

![img](https://img.xiaoyou66.com/2021/03/30/ee57504a3b1e1.jpg)

## 类加载机制

只需要记住下面这5个阶段就行了

![img](https://img.xiaoyou66.com/2021/03/23/6db4376bea983.png)

下面简单介绍一下每个部分做了啥

- **加载** 首先获取二进制流，然后把字节流所代表的静态存储结构转化为方法区的运行时数据结构，最后在java堆中生成一个代表这个类的java.lang.Class对象，作为数据访问入口
- **验证** 确保被加载类的正确性，分为文件格式验证，元数据验证，字节码验证和符合引用验证
- **准备** 为类的静态变量分配内存，并将其初始化为默认值
- **解析** 把类中的符号引用转换为直接引用
- **初始化** 初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化
- **使用** 类访问方法区内的数据结构的接口， 对象是Heap区的数据
- **卸载**

## 双亲委派模型

类加载器可以细分为下面几种类型

![image.png](https://img.xiaoyou66.com/2021/03/23/fafa7c8626766.png)

它们之间的层次关系被称为类加载器的**双亲委派模型**。该模型要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器，而这种父子关系一般通过**组合（Composition）关系**来实现，而不是通过继承（Inheritance）。

当应用类加载器获取到一个类加载的请求的时候，不会立即处理这个类加载请求，而是将这个请求委派给他的父加载器加载，如果这个父加载器不能够处理这个类加载请求，便将之传递给子加载器。一级一级传递指导可以加载该类的类加载器。

### 双亲委派可以破坏吗

## new新建对象过程

![img](https://img.xiaoyou66.com/2021/03/30/592899b0b7057.jpg)

这个其实相当于类加载的机制

当虚拟机遇见new关键字时候，实现判断当前类是否已经加载，如果类没有加载，首先执行类的加载机制，加载完成后再为对象分配空间、初始化等。

1. 首先校验当前类是否被加载，如果没有加载，执行类加载机制
2. 加载：就是从字节码加载成二进制流的过程
3. 验证：当然加载完成之后，当然需要校验Class文件是否符合虚拟机规范，跟我们接口请求一样，第一件事情当然是先做个参数校验了
4. 准备：为静态变量、常量赋默认值
5. 解析：把常量池中符号引用(以符号描述引用的目标)替换为直接引用(指向目标的指针或者句柄等)的过程
6. 初始化：执行static代码块(cinit)进行初始化，如果存在父类，先对父类进行初始化

Ps：静态代码块是绝对线程安全的，只能隐式被java虚拟机在类加载过程中初始化调用！(此处该有问题static代码块线程安全吗？)

当类加载完成之后，紧接着就是对象分配内存空间和初始化的过程

1. 首先为对象分配合适大小的内存空间
2. 接着为实例变量赋默认值
3. 设置对象的头信息，对象hash码、GC分代年龄、元数据信息等
4. 执行构造函数(init)初始化

##  判断对象是否是垃圾

### 引用计数算法：判断对象的引用数量

每引用一次就+1，当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数减 1，当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器均减 1，当引用次数为0时就会当成垃圾，

**问题** 当两个对象循环引用时，这个垃圾就无法回收

### 可达性分析算法：判断对象的引用链是否可达

通过一系列的名为 “GC Roots” 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain）。当一个对象到 GC Roots 没有任何引用链相连（用图论的话来说就是从 GC Roots 到这个对象不可达）时，则证明此对象是不可用的

![img](https://img.xiaoyou66.com/2021/03/23/1979a28681ca1.jpg)

有哪些是GC ROOT

1. 栈中引用的对象
2. 静态变量、常量引用的对象
3. 本地方法栈native方法引用的对象

## 垃圾回收三种算法

标记删除（mark-sweep）、拷贝（copying）、标记压缩（mark-compact）

- **标记删除** 就是把垃圾区域标记出来，然后清除出去（问题：碎片化）
- **拷贝** 先将内存分成俩半，把要清除的一半有用的区域复制到另一半，然后清除这一半（浪费空间）
- **标记整理** 对内存进行整理，有用的堆到前面，没用的堆到后面，一边标记一边整理（效率低）
- **分代收集** 不同的对象生命周期不一样，我们可以通过分成不同的代，不同代使用不同的算法（新生代使用拷贝 老年代使用标记整理）

JVM是拷贝和标记整理两个算法结合使用

## Java堆内存逻辑分区（分代模型）

![image-20210323111431114](https://img.xiaoyou66.com/2021/03/23/f040c4f6128b4.png)

- 内存分为俩大块，一个是新生代区域，一个是老年代区域。
- 新生代包括伊甸区、survivor1和survivor2
- 老年代只有一块，但是占的空间更大

### 详细流程

1. 当我们初始化一个对象时，首先会判断是否可以分配到栈上，如果可以就直接分配到栈上，不行就下一步
2. 然后判断是不是大对象，大对象可以直接分配到老年代，小对象需要判断是否启动了本地线程分配缓存(TLAB)，如果有则将按线程优先在TLAB上分配。
3. 然后就是回收了，一开始垃圾回收器会把S2和伊甸区有用的数据都复制S1中（这里用到了垃圾回收的拷贝），然后清空伊甸区和S2，第二次GC时会把S1和伊甸区的有用的对象都放入S2中，然后清空S1和伊甸区，如此循环往复。
4. 新生代每次GC年龄都会增长1，当年龄到达15时会进入老年代（老年代采用的是标记整理算法）

![image-20210311100052826](https://img.xiaoyou66.com/2021/03/23/f47791111b4b1.png)

TLAB：Thread Local Allocation Buffer（线程本地分配缓冲区）eden区有一个线程本地缓冲空间，避免争抢，如果线程需要，就new到线程自己身上去

## 垃圾回收器

垃圾回收器其实就是**进行垃圾回收算法时** 用于垃圾标记的算法

![image-20210310222838854](https://img.xiaoyou66.com/2021/03/23/00ec8ab4bb92a.png)

1. Epslion：最没用的，就是个摆设，就调试用的到（Debug）
2. Parallel Scavenge：采用多线程切GC
3. Parallel Old：采用多线程切GC
4. Serial：stw（stop the world）单线程，停止工作线程，进行GC（很少用了）
5. Serial Old：单线程，停止工作线程，进行GC（很少用了）
6. CMS(重点！！！！)：工作在老年代
7. ParNew：和Parallel Scavenge一样，只不过是用来配合CMS
8. G1：针对分区模型的回收器
9. ZGC：针对分区模型的回收器
10. Shenandosh：针对分区模型的回收器

## CMS垃圾回收器

用于回收老年代的垃圾

- 初始标记：标记老年代root对象
- 并发标记：对root对象往下进行标记
- 重新标记：修正错标的内容（三色标记算法）
- 并发清理：清理垃圾，也会产生浮动垃圾，下次处理

注意：这里标记的时候会STW，把当前的进程停止，然后进行标记，然后在恢复线程（蓝色的就是我们的实际线程了，黄色的是标记和垃圾回收线程）

![image-20210312214042432](https://img.xiaoyou66.com/2021/03/23/5dab2b981f8b8.png)

## G1垃圾回收器

这个是jdk9中默认采用的垃圾回收器。

jdk1.8之前，我们的内存空间划分是连续的（注意：jdk8去除了永久代，引入了元空间的概念）

![传统GC内存布局](https://img.xiaoyou66.com/2021/03/31/c548b89bcebdc.png)

而G1的各代存储地址是不连续的，每一代都使用了n个不连续的大小相同的Region，每个Region占有一块连续的虚拟内存地址。如下图所示：（H存储的是一些巨大的对象，即大小大于等于region一半的对象）

![g1 GC内存布局](https://img.xiaoyou66.com/2021/03/31/a61074ab59254.png)

G1垃圾回收的流程

- **G1执行的第一阶段：初始标记(Initial Marking )**

  这个阶段是STW(Stop the World )的，所有应用线程会被暂停，标记出从GC Root开始直接可达的对象。

- **G1执行的第二阶段：并发标记**

  从GC Roots开始对堆中对象进行可达性分析，找出存活对象，耗时较长。当并发标记完成后，开始最终标记(Final Marking )阶段

- **最终标记**

  标记那些在并发标记阶段发生变化的对象，将被回收。

- **筛选回收**

  首先对各个Regin的回收价值和成本进行排序，根据用户所期待的GC停顿时间指定回收计划，回收一部分Region。

最后，G1中提供了两种模式垃圾回收模式，Young GC和Mixed GC，两种都是Stop The World(STW)的。

## YGC和FGC

YGC ：对新生代堆进行gc。 频率比较高，因为大部分对象的存活寿命较短，在新生代里被回收。 FGC ：全堆范围的gc。

当一个新的对象来申请内存空间的时候，如果Eden区无法满足内存分配需求，则触发YGC，使用中的Survivor区和Eden区存活对象送到未使用的Survivor区，如果YGC之后还是没有足够空间，则直接进入老年代分配，如果老年代也无法分配空间，触发FGC，FGC之后还是放不下则报出OOM异常。

最复杂的是所谓的悲观策略，它触发的机制是在首先会计算之前晋升的平均大小，也就是从新生代，通过ygc变成新生代的平均大小，然后如果旧生代剩余的空间小于晋升大小，那么就会触发一次FullGC。sdk考虑的策略是， 从平均和长远的情况来看，下次晋升空间不够的可能性非常大， 与其等到那时候在fullGC 不如悲观的认为下次肯定会触发FullGC， 直接先执行一次FullGC。而且从实际使用过程中来看， 也达到了比较稳定的效果。



## JMM内存模型

`Java内存模型(JavaMemoryModel)`描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量，存储到内存和从内存中读取变量这样的底层细节。

### JMM有以下规定：

所有的共享变量都存储于主内存，这里所说的变量指的是实例变量和类变量，不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。

每一个线程还存在自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本。

`线程对变量的所有的操作(读，取)都必须在工作内存中完成，而不能直接读写主内存中的变量`。

不同线程之间也不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主内存中转来完成。

![图片](https://mmbiz.qpic.cn/mmbiz_jpg/uChmeeX1FpzhiaXUhn9W2XjuqeziaG1ibdvOgPyiaPib3U7oR6ZS77CqlAVp7BkTxS30UhDN1X6YJRfCGQadBP6xd9Q/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)