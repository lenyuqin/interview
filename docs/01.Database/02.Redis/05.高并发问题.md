---
title: 高并发
date: 2021-04-10 13:21:14
permalink: /pages/daf174/
categories:
  - Redis
tags:
  - 
---

## 缓存穿透

`redis缓存`和`数据库`中没有相关数据(例用户直接携带`id<=0`的参数不断发起请求)，redis中没有这样的数据，`无法进行拦截`，直接被穿透到`数据库`，导致数据库压力过大宕机。

### 解决方案

- 对不存在的数据缓存到redis中，设置key，value值为null(不管是数据未null还是系统bug问题)，并设置一个短期过期时间段，避免过期时间过长影响正常用户使用。
- 拉黑该IP地址
- 对参数进行校验，不合法参数进行拦截
- 布隆过滤器 将所有可能存在的数据哈希到一个足够大的bitmap(位图)中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。

### Bloom Filter

使用布隆过滤器得到的判断结果：`不存在的一定不存在，存在的不一定存在`。

布隆过滤器原理：

> 当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组中的K个点(有效降低冲突概率)，把它们置为1。检索时，我们只要看看这些点是不是都是1就知道集合中有没有它了：如果这些点有任何一个为0，则被检元素一定不在；如果都是1，则被检元素很可能在。这就是布隆过滤器的基本思想。

![图片](https://mmbiz.qpic.cn/mmbiz_png/wJvXicD0z2dX4ksecYaj2nLDUQtGalKRic4nG6bxaV4zdIpGjBqzdhicMicC8tqv3pyDNDXVg1tHZRyugicicVhrzX8w/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

## 缓存击穿

`某一个`热点key，在不停地扛着高并发，当这个热点key在`失效的一瞬间`，持续的高并发访问就`击破缓存`直接访问数据库，导致数据库宕机。

### 解决方案

- 设置热点数据"永不过期"

- 加上互斥锁：上面的现象是多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一个互斥锁来锁住它，其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后将数据放到redis缓存起来。后面的线程进来发现已经有缓存了，就直接走缓存


## 缓存雪崩

雪崩是`大面积`的key缓存失效；穿透是redis里`不存在`这个缓存key；击穿是redis`某一个热点`key突然失效，最终的受害者都是数据库。

### 解决方案

1. 将redis、MySQL等搭建成高可用的集群，防止单点。

2. 服务中进行限流 + 降级，防止MySQL被打崩溃。

3. Redis 持久化 RDB+AOF，宕机重启，自动从磁盘上加载数据，快速恢复缓存数据。




