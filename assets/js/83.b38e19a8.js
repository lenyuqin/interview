(window.webpackJsonp=window.webpackJsonp||[]).push([[83],{490:function(_,v,t){"use strict";t.r(v);var i=t(21),n=Object(i.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h2",{attrs:{id:"二维码登陆"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二维码登陆"}},[_._v("#")]),_._v(" 二维码登陆")]),_._v(" "),t("p",[_._v("二维码登录本质上也是一种登录认证方式。既然是登录认证，要做的也就两件事情！")]),_._v(" "),t("ol",[t("li",[_._v("告诉系统我是谁")]),_._v(" "),t("li",[_._v("向系统证明我是谁")])]),_._v(" "),t("p",[t("img",{attrs:{src:"https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9Tw1Ct5icMTbQz3VAV15DbZbtXd0aiaib3IzncU8XynuTu52eJlGQrnooGmQ7fawxnD88rria17xXs3UKQ/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}})]),_._v(" "),t("p",[_._v("账号密码登录时，客户端会将设备信息一起传递给服务端，")]),_._v(" "),t("p",[_._v("如果账号密码校验通过，服务端会把账号与设备进行一个绑定，存在一个数据结构中，这个数据结构中包含了账号 ID，设备 ID，设备类型等等")]),_._v(" "),t("p",[_._v("然后服务端会生成一个 token，用它来映射数据结构，这个 token 其实就是一串有着特殊意义的字符串，它的意义就在于，通过它可以找到对应的账号与设备信息，")]),_._v(" "),t("ol",[t("li",[_._v("客户端得到这个 token 后，需要进行一个本地保存，每次访问系统 API 都携带上 token 与设备信息。")]),_._v(" "),t("li",[_._v("服务端就可以通过 token 找到与它绑定的账号与设备信息，然后把绑定的设备信息与客户端每次传来的设备信息进行比较， 如果相同，那么校验通过，返回 AP 接口响应数据， 如果不同，那就是校验不通过拒绝访问")])]),_._v(" "),t("p",[_._v("从前面这个流程，我们可以看到，客户端不会也没必要保存你的密码，相反，它是保存了 token。可能有些同学会想，这个 token 这么重要，万一被别人知道了怎么办。实际上，知道了也没有影响， 因为设备信息是唯一的，只要你的设备信息别人不知道， 别人拿其他设备来访问，验证也是不通过的。")]),_._v(" "),t("p",[_._v("可以说，客户端登录的目的，就是获得属于自己的 token")]),_._v(" "),t("ol",[t("li",[t("p",[_._v("二维码的背后它一定存在一个唯一性的 ID，当二维码生成时，这个 ID 也一起生成，并且绑定了 PC 端的设备信息")])]),_._v(" "),t("li",[t("p",[_._v("手机去扫描这个二维码")])]),_._v(" "),t("li",[t("p",[_._v("二维码切换为 已扫描待确认状态， 此时就会将账号信息与这个 ID 绑定")])]),_._v(" "),t("li",[t("p",[_._v("当手机端确认登录时，它就会生成 PC 端用于登录的 token，并返回给 PC 端")])]),_._v(" "),t("li",[t("p",[_._v("PC 端向服务端发起请求，告诉服务端，我要生成用户登录的二维码，并且把 PC 端设备信息也传递给服务端")])]),_._v(" "),t("li",[t("p",[_._v("服务端收到请求后，它生成二维码 ID，并将二维码 ID 与 PC 端设备信息进行绑定")])]),_._v(" "),t("li",[t("p",[_._v("然后把二维码 ID 返回给 PC 端")])]),_._v(" "),t("li",[t("p",[_._v("PC 端收到二维码 ID 后，生成二维码(二维码中肯定包含了 ID)")])]),_._v(" "),t("li",[t("p",[_._v("为了及时知道二维码的状态，客户端在展现二维码后，PC 端不断的轮询服务端，比如每隔一秒就轮询一次，请求服务端告诉当前二维码的状态及相关信息")])]),_._v(" "),t("li",[t("p",[_._v("用户用手机去扫描 PC 端的二维码，通过二维码内容取到其中的二维码 ID")])]),_._v(" "),t("li",[t("p",[_._v("再调用服务端 API 将移动端的身份信息与二维码 ID 一起发送给服务端")])]),_._v(" "),t("li",[t("p",[_._v("服务端接收到后，它可以将身份信息与二维码 ID 进行绑定，生成临时 token。然后返回给手机端")])]),_._v(" "),t("li",[t("p",[_._v("因为 PC 端一直在轮询二维码状态，所以这时候二维码状态发生了改变，它就可以在界面上把二维码状态更新为已扫描")])])]),_._v(" "),t("p",[_._v("那么为什么需要返回给手机端一个临时 token 呢？临时 token 与 token 一样，它也是一种身份凭证，不同的地方在于它只能用一次，用过就失效。")]),_._v(" "),t("p",[_._v("在第三步骤中返回临时 token，为的就是手机端在下一步操作时，可以用它作为凭证。以此确保扫码，登录两步操作是同一部手机端发出的，")]),_._v(" "),t("ol",[t("li",[_._v("手机端在接收到临时 token 后会弹出确认登录界面，用户点击确认时，手机端携带临时 token 用来调用服务端的接口，告诉服务端，我已经确认")]),_._v(" "),t("li",[_._v("服务端收到确认后，根据二维码 ID 绑定的设备信息与账号信息，生成用户 PC 端登录的 token")]),_._v(" "),t("li",[_._v('这时候 PC 端的轮询接口，它就可以得知二维码的状态已经变成了"已确认"。并且从服务端可以获取到用户登录的 token')]),_._v(" "),t("li",[_._v("到这里，登录就成功了，后端 PC 端就可以用 token 去访问服务端的资源了")])]),_._v(" "),t("p",[_._v("参考：https://mp.weixin.qq.com/s/l9WUXotDjVg1L9zg3rWNnA")])])}),[],!1,null,null,null);v.default=n.exports}}]);