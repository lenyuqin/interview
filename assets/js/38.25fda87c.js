(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{445:function(t,s,a){"use strict";a.r(s);var r=a(21),e=Object(r.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"tls是啥"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tls是啥"}},[t._v("#")]),t._v(" TLS是啥")]),t._v(" "),a("p",[t._v("SSL/TLS协议其实就是一个安全通信的协议，https采用的就是这个协议来实现安全传输，这个地方主要会问你https的工作原理由")]),t._v(" "),a("h2",{attrs:{id:"常见的加密算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常见的加密算法"}},[t._v("#")]),t._v(" 常见的加密算法")]),t._v(" "),a("h3",{attrs:{id:"对称加密算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对称加密算法"}},[t._v("#")]),t._v(" 对称加密算法")]),t._v(" "),a("p",[t._v("DES、3DES、DESX、Blowfish、IDEA、RC4、RC5、RC6和AES")]),t._v(" "),a("h3",{attrs:{id:"非对称加密算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#非对称加密算法"}},[t._v("#")]),t._v(" 非对称加密算法")]),t._v(" "),a("p",[t._v("RSA、ECC（移动设备用）、Diffie-Hellman、El Gamal、DSA（数字签名用）")]),t._v(" "),a("h3",{attrs:{id:"摘要、hash算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#摘要、hash算法"}},[t._v("#")]),t._v(" 摘要、hash算法")]),t._v(" "),a("p",[t._v("MD2、MD4、MD5、HAVAL、SHA、SHA-1、HMAC、HMAC-MD5、HMAC-SHA1")]),t._v(" "),a("h2",{attrs:{id:"洪水攻击"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#洪水攻击"}},[t._v("#")]),t._v(" 洪水攻击")]),t._v(" "),a("p",[t._v("SYN Flood 或称 SYN洪水、SYN洪泛是一种阻断服务攻击，起因于攻击者传送一系列的SYN请求到目标系统。")]),t._v(" "),a("p",[t._v("tcp半链接攻击也称为：SYN Flood (SYN洪水)，是种典型的DoS (Denial of Service，拒绝服务) 攻击，效果就是服务器TCP连接资源耗尽，停止响应正常的TCP连接请求")]),t._v(" "),a("h2",{attrs:{id:"dns攻击"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dns攻击"}},[t._v("#")]),t._v(" dns攻击")]),t._v(" "),a("h3",{attrs:{id:"dns服务器被劫持"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dns服务器被劫持"}},[t._v("#")]),t._v(" dns服务器被劫持")]),t._v(" "),a("p",[t._v("我们知道一个域名服务器对其区域内的用户解析请求负责，但是并没有一个机制去监督它有没有真地负责。也就是说域名服务器的权力并没有被关在笼子里，所以它既可以认真地“为人民服务”，也可以“指鹿为马”。于是有些流氓的域名服务器故意更改一些域名的解析结果，将用户引向一个错误的目标地址。这就叫作 DNS 劫持，主要用来阻止用户访问某些特定的网站，或者是将用户引导到广告页面")]),t._v(" "),a("h3",{attrs:{id:"dns欺骗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dns欺骗"}},[t._v("#")]),t._v(" dns欺骗")]),t._v(" "),a("p",[t._v("DNS 欺骗简单来说就是用一个假的 DNS 应答来欺骗用户计算机，让其相信这个假的地址，并且抛弃真正的 DNS 应答。在一台主机发出 DNS 请求后，它就开始等待应答，如果此时有一个看起来正确（拥有和DNS请求一样的序列号）的应答包，它就会信以为真，并且丢弃稍晚一点到达的应答。")]),t._v(" "),a("h2",{attrs:{id:"xss"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#xss"}},[t._v("#")]),t._v(" XSS")]),t._v(" "),a("p",[t._v("XSS全称是Cross-site scripting，有点前端安全基础的同学应该都知道。就是通过一些用户可以输入的界面，比如评论，填入一些非法字符，如"),a("code",[t._v(">alert(document.cookie)")]),t._v("等类似的方式，导致网页做些这个“史壳郎”想要的一些操作。\n怎么防御呢？这种现象的产生原因无非是，前端模板或者后端模板在渲染的时候没有进行字符转译，导致"),a("code",[t._v("<>")]),t._v("这样的字符直接就渲染到了页面上。\n所以，我们只需要在渲染前做一次转译，将这些符号转为字符实体就好了。幸运的是，现在的前端库，如vue，react，前端模板ejs，juicer，后端模板smarty，blade等，都已经内部做了转译了，开发者愉快的使用就好了。所以，其实我们完全不用做任何额外的工作。但是，还是理解内部机制比较好。")]),t._v(" "),a("h2",{attrs:{id:"csrf"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#csrf"}},[t._v("#")]),t._v(" CSRF")]),t._v(" "),a("p",[t._v("CSRF全称是Cross-site request forgery。这个的话其实很多公司都不太做这个防御，我问过挺多朋友，他们公司的确并不关心这个。\n好吧，，，不过其实，这种攻击的确在如今，对用户或者公司的危害非常小，不过还是要做的，因为，对于网络安全，我们是认真的！\n攻击场景的话，比如：网页有一个对作品点赞的功能，点赞提交地址为"),a("code",[t._v("http://csrf.com/api.like?id=777")]),t._v("，然后另外一个网站放了这样一个元素``，这样的话，一旦用户进入这个bbb.com页面，就会请求csrf.com/api.like这个接口，因为用户的登录信息尚未过期，那就等于给id为888这个作品点赞了。\n防御方式：")]),t._v(" "),a("ol",[a("li",[t._v("后端判断referer是否合法（不推荐）")]),t._v(" "),a("li",[t._v("每次请求都要带上token，token是csrf.com页面渲染时一起带过来的，这样的话，如果不在csrf.com页面发起这个点赞请求，token是不存在的，因为就能做到防御了。")])])])}),[],!1,null,null,null);s.default=e.exports}}]);