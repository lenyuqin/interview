(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{422:function(v,_,t){"use strict";t.r(_);var r=t(21),s=Object(r.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"rdb"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rdb"}},[v._v("#")]),v._v(" RDB")]),v._v(" "),t("p",[v._v("RDB 持久化机制，是对 Redis 中的数据执行周期性的持久化。更适合做冷备。")]),v._v(" "),t("p",[t("strong",[v._v("优点：")])]),v._v(" "),t("ol",[t("li",[v._v("压缩后的二进制文，适用于备份、全量复制，用于灾难恢复加载RDB恢复数据远快于AOF方式，适合大规模的数据恢复。")]),v._v(" "),t("li",[v._v("如果业务对数据完整性和一致性要求不高，RDB是很好的选择。数据恢复比AOF快。")])]),v._v(" "),t("p",[t("strong",[v._v("缺点：")])]),v._v(" "),t("ol",[t("li",[v._v("RDB是"),t("strong",[v._v("周期间隔性的快照文件")]),v._v("，数据的完整性和一致性不高，因为RDB可能在最后一次备份时宕机了。")]),v._v(" "),t("li",[v._v("备份时占用内存，因为Redis 在备份时会独立fork一个"),t("strong",[v._v("子进程")]),v._v("，将数据写入到一个临时文件（此时内存中的数据是原来的两倍哦），最后再将临时文件替换之前的备份文件。所以要考虑到大概两倍的数据膨胀性。")])]),v._v(" "),t("p",[v._v("两种触发方式")]),v._v(" "),t("ol",[t("li",[t("code",[v._v("SAVE")]),v._v(" 直接调用 rdbSave ，"),t("code",[v._v("阻塞")]),v._v(" Redis 主进程，导致无法提供服务。")]),v._v(" "),t("li",[t("code",[v._v("BGSAVE")]),v._v(" 则 fork 出一个子进程，子进程负责调用 rdbSave ，在保存完成后向主进程发送信号告知完成。在BGSAVE 执行期间"),t("strong",[v._v("仍可以继续处理客户端的请求")]),v._v("。")])]),v._v(" "),t("h3",{attrs:{id:"cow机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cow机制"}},[v._v("#")]),v._v(" COW机制")]),v._v(" "),t("p",[v._v("目的是为了解决RDB后台备份时，保证快照是精准的")]),v._v(" "),t("p",[v._v("全称Copy On Write，备份的是开始那个时刻内存中的数据，只复制被修改内存页数据，不是全部内存数据。")]),v._v(" "),t("p",[t("strong",[v._v("缺点：")]),v._v(" Copy On Write时如果父子进程大量写操作会导致分页错误。")]),v._v(" "),t("h2",{attrs:{id:"aof"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#aof"}},[v._v("#")]),v._v(" AOF")]),v._v(" "),t("p",[v._v("AOF 机制对每条写入命令作为日志，以 append-only 的模式写入一个日志文件中，因为这个模式是"),t("strong",[v._v("只追加")]),v._v("的方式，所以没有任何磁盘寻址的开销，所以很快，有点像 Mysql 中的binlog。AOF更适合做热备。")]),v._v(" "),t("p",[t("strong",[v._v("优点：")]),v._v(" AOF是一秒一次去通过一个后台的线程fsync操作，数据丢失不用怕。")]),v._v(" "),t("p",[t("strong",[v._v("缺点：")])]),v._v(" "),t("ol",[t("li",[v._v("对于相同数量的数据集而言，AOF文件通常要大于RDB文件。RDB 在"),t("strong",[v._v("恢复")]),v._v("大数据集时的速度比 AOF 的恢复速度要快。")]),v._v(" "),t("li",[v._v("根据同步策略的不同，AOF在运行效率上往往会慢于RDB。总之，每秒同步策略的效率是比较高的。")])]),v._v(" "),t("h3",{attrs:{id:"执行流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#执行流程"}},[v._v("#")]),v._v(" 执行流程")]),v._v(" "),t("ol",[t("li",[v._v("命令的实时写入，不同级别可能有1秒数据损失。命令先追加到"),t("code",[v._v("aof_buf")]),v._v("然后再同步到AO磁盘，"),t("strong",[v._v("如果实时写入磁盘会带来非常高的磁盘IO，影响整体性能")]),v._v("。")]),v._v(" "),t("li",[v._v("对aof文件的"),t("strong",[v._v("重写")]),v._v("，目的是为了减少AOF文件的大小，可以自动触发或者手动触发("),t("strong",[v._v("BGREWRITEAOF")]),v._v(")，Fork出子进程操作，期间Redis服务仍可用。")])]),v._v(" "),t("p",[v._v("流程图如下：")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://img.xiaoyou66.com/2021/03/21/61cdc99df3f70.png",alt:"图片"}})]),v._v(" "),t("p",[t("strong",[v._v("注意事项：")])]),v._v(" "),t("ol",[t("li",[v._v("在重写期间，由于主进程依然在响应命令，为了保证最终备份的完整性；它"),t("code",[v._v("依然会写入旧")]),v._v("的AOF中，如果重写失败，能够保证数据不丢失")]),v._v(" "),t("li",[v._v("为了把重写期间响应的写入信息也写入到新的文件中，因此也会"),t("code",[v._v("为子进程保留一个buf")]),v._v("，防止新写的file丢失数据")]),v._v(" "),t("li",[v._v("重写是直接把"),t("code",[v._v("当前内存的数据生成对应命令")]),v._v("，并不需要读取老的AOF文件进行分析、命令合并")]),v._v(" "),t("li",[t("strong",[v._v("无论是 RDB 还是 AOF 都是先写入一个临时文件，然后通过"),t("code",[v._v("rename")]),v._v("完成文件的替换工作")])])]),v._v(" "),t("p",[t("strong",[v._v("fork的建议：")])]),v._v(" "),t("ol",[t("li",[v._v("降低fork的频率，比如可以手动来触发RDB生成快照、与AOF重写")]),v._v(" "),t("li",[v._v("控制Redis最大使用内存，防止fork耗时过长")]),v._v(" "),t("li",[v._v("合理配置Linux的内存分配策略，避免因为物理内存不足导致fork失败")]),v._v(" "),t("li",[v._v("Redis在执行"),t("code",[v._v("BGSAVE")]),v._v("和"),t("code",[v._v("BGREWRITEAOF")]),v._v("命令时，哈希表的负载因子>=5，而未执行这两个命令时>=1。目的是"),t("strong",[v._v("尽量减少写操作")]),v._v("，避免不必要的内存写入操作")]),v._v(" "),t("li",[t("strong",[v._v("哈希表的扩展因子")]),v._v("：哈希表已保存节点数量 / 哈希表大小。因子决定了是否扩展哈希表")])]),v._v(" "),t("h2",{attrs:{id:"恢复"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#恢复"}},[v._v("#")]),v._v(" 恢复")]),v._v(" "),t("p",[v._v("启动时会先检查AOF(数据更完整)文件是否存在，如果不存在就尝试加载RDB。")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://img.xiaoyou66.com/2021/03/21/f5e3fbb0d1606.png",alt:"图片"}})]),v._v(" "),t("h2",{attrs:{id:"建议"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#建议"}},[v._v("#")]),v._v(" 建议")]),v._v(" "),t("p",[v._v("既然单独用RDB会丢失很多数据。单独用AOF，数据恢复没RDB来的快，所以出现问题了第一时间用RDB恢复，然后AOF做数据补全。")]),v._v(" "),t("h2",{attrs:{id:"优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#优化"}},[v._v("#")]),v._v(" 优化")]),v._v(" "),t("p",[v._v("后续在4.x进行了优化，进行混合使用")]),v._v(" "),t("p",[t("img",{attrs:{src:"https://i.loli.net/2021/04/14/HfNDnjBMEW8SIyk.png",alt:"image-20210414132108740"}})]),v._v(" "),t("p",[v._v("AOF记录一个当时的一个RDB快照和记录那个时刻后面的日志记录，结合两者的优点")]),v._v(" "),t("p",[v._v("恢复的时候就可以先根据那个时间的RDB文件快照先恢复，然后那个时间点后面的就用指令进行恢复，保证了完整性")])])}),[],!1,null,null,null);_.default=s.exports}}]);