(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{412:function(t,_,s){"use strict";s.r(_);var v=s(21),r=Object(v.a)({},(function(){var t=this,_=t.$createElement,s=t._self._c||_;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"mysql-索引-优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mysql-索引-优化"}},[t._v("#")]),t._v(" MySQL 索引，优化")]),t._v(" "),s("h3",{attrs:{id:"_1-最左匹配原则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-最左匹配原则"}},[t._v("#")]),t._v(" 1.最左匹配原则")]),t._v(" "),s("h4",{attrs:{id:"介绍"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[t._v("#")]),t._v(" 介绍")]),t._v(" "),s("p",[t._v("如果建立的是复合索引，索引的顺序要按照建立时的顺序，即从左到右，如：a->b->c（和 B+树的数据结构有关）")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdnimg.cn/20210129222650447.png",alt:""}})]),t._v(" "),s("h4",{attrs:{id:"无效索引举例"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#无效索引举例"}},[t._v("#")]),t._v(" 无效索引举例")]),t._v(" "),s("ul",[s("li",[t._v("a->c：a 有效，c 无效")]),t._v(" "),s("li",[t._v("b->c：b、c 都无效")]),t._v(" "),s("li",[t._v("c：c 无效")])]),t._v(" "),s("h3",{attrs:{id:"_2-覆盖索引"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-覆盖索引"}},[t._v("#")]),t._v(" 2.覆盖索引")]),t._v(" "),s("p",[t._v("在B+树的索引中，叶子节点可能存储了当前的key值，也可能存储了当前的key值以及整行的数据，这就是聚簇索引和非聚簇索引。 在InnoDB中，只有主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引。如果没有唯一键，则隐式的生成一个键来建立聚簇索引。")]),t._v(" "),s("p",[t._v("当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再次进行回表查询。")]),t._v(" "),s("h3",{attrs:{id:"_3-回表问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-回表问题"}},[t._v("#")]),t._v(" 3.回表问题")]),t._v(" "),s("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://i.loli.net/2021/03/29/3hsZPReYn5BjwI2.jpg",alt:"普通索引"}}),t._v(" "),s("h3",{attrs:{id:"_4-索引"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-索引"}},[t._v("#")]),t._v(" 4.索引")]),t._v(" "),s("h4",{attrs:{id:"索引建多会有什么问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#索引建多会有什么问题"}},[t._v("#")]),t._v(" 索引建多会有什么问题")]),t._v(" "),s("ul",[s("li",[t._v("实际上索引也是一张表，该表保存了主键和索引字段，并指向实体表的记录，所以索引列也是要占用空间的")]),t._v(" "),s("li",[t._v("虽然索引大大提高了查询速度，同时却会降低更新表的速度，如果对表INSERT，，UPDATE和DELETE。因为更新表时，MySQL不仅要不存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息")]),t._v(" "),s("li",[t._v("索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立优秀的索引，或优化查询语句")])]),t._v(" "),s("h4",{attrs:{id:"哪些情况需要建索引"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#哪些情况需要建索引"}},[t._v("#")]),t._v(" 哪些情况需要建索引")]),t._v(" "),s("ul",[s("li",[t._v("主键自动建立唯一索引")]),t._v(" "),s("li",[t._v("频繁作为查询的条件的字段应该创建索引")]),t._v(" "),s("li",[t._v("查询中与其他表关联的字段，外键关系建立索引")]),t._v(" "),s("li",[t._v("频繁更新的字段不适合创建索引：因为每次更新不单单是更新了记录还会更新索引，加重IO负担")]),t._v(" "),s("li",[t._v("Where条件里用不到的字段不创建索引")]),t._v(" "),s("li",[t._v("单间/组合索引的选择问题（在高并发下倾向创建组合索引）")]),t._v(" "),s("li",[t._v("查询中排序的字段，若通过索引去访问将大大提高排序的速度")]),t._v(" "),s("li",[t._v("查询中统计或者分组字段")])]),t._v(" "),s("h4",{attrs:{id:"哪些不适合建索引"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#哪些不适合建索引"}},[t._v("#")]),t._v(" 哪些不适合建索引")]),t._v(" "),s("ul",[s("li",[t._v("表记录太少")]),t._v(" "),s("li",[t._v("经常增删改的表")]),t._v(" "),s("li",[t._v("数据重复且分布平均的表字段，因此应该只为经常查询和经常排序的数据列建立索引。注意，如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。")])]),t._v(" "),s("h4",{attrs:{id:"以下用法会导致索引失效"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#以下用法会导致索引失效"}},[t._v("#")]),t._v(" 以下用法会导致索引失效")]),t._v(" "),s("ul",[s("li",[t._v("计算，如：+、-、*、/、!=、<>、is null、is not null、or")]),t._v(" "),s("li",[t._v("函数，如：sum()、round()等等")]),t._v(" "),s("li",[t._v('手动/自动类型转换，如：id = "1"，本来是数字，给写成字符串了')])]),t._v(" "),s("h3",{attrs:{id:"_5-explain用法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-explain用法"}},[t._v("#")]),t._v(" 5.Explain用法")]),t._v(" "),s("p",[t._v("Explain + SQL 语句;")]),t._v(" "),s("p",[t._v("如：Explain select * from user;\n会生成如下 SQL 分析结果，下面详细对每个字段进行详解")]),t._v(" "),s("h4",{attrs:{id:"一、id"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一、id"}},[t._v("#")]),t._v(" 一、id")]),t._v(" "),s("p",[t._v("是一组数字，代表多个表之间的查询顺序，或者包含子句查询语句中的顺序，id 总共分为三种情况，依次详解")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("id 相同，执行顺序由上至下")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdnimg.cn/20210129215127511.png",alt:""}})])]),t._v(" "),s("li",[s("p",[t._v("id 不同，如果是子查询，id 号会递增，id 值越大优先级越高，越先被执行")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdnimg.cn/20210129215146760.png",alt:""}})])]),t._v(" "),s("li",[s("p",[t._v("id 相同和不同的情况同时存在")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdnimg.cn/202101292152064.png",alt:""}})])])]),t._v(" "),s("h4",{attrs:{id:"二、select-type"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二、select-type"}},[t._v("#")]),t._v(" 二、select_type")]),t._v(" "),s("p",[t._v("select_type 包含以下几种值")]),t._v(" "),s("ul",[s("li",[t._v("simple")]),t._v(" "),s("li",[t._v("primary")]),t._v(" "),s("li",[t._v("subquery")]),t._v(" "),s("li",[t._v("derived")]),t._v(" "),s("li",[t._v("union")]),t._v(" "),s("li",[t._v("union result")])]),t._v(" "),s("p",[s("strong",[t._v("simple")])]),t._v(" "),s("p",[t._v("简单的 select 查询，查询中不包含子查询或者 union 查询")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdnimg.cn/20210129215230858.png",alt:""}})]),t._v(" "),s("p",[s("strong",[t._v("primary")])]),t._v(" "),s("p",[t._v("如果 SQL 语句中包含任何子查询，那么子查询的最外层会被标记为 primary")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdnimg.cn/202101292152467.png",alt:""}})]),t._v(" "),s("p",[s("strong",[t._v("subquery")])]),t._v(" "),s("p",[t._v("在 select 或者 where 里包含了子查询，那么子查询就会被标记为 subQquery，同三.二同时出现")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdnimg.cn/20210129215310227.png",alt:""}})]),t._v(" "),s("p",[s("strong",[t._v("derived")])]),t._v(" "),s("p",[t._v("在 from 中包含的子查询，会被标记为衍生查询，会把查询结果放到一个临时表中")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdnimg.cn/20210129215332420.png",alt:""}})]),t._v(" "),s("p",[s("strong",[t._v("union / union result")])]),t._v(" "),s("p",[t._v("如果有两个 select 查询语句，他们之间用 union 连起来查询，那么第二个 select 会被标记为 union，union 的结果被标记为 union result。它的 id 是为 null 的")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdnimg.cn/20210129215354818.png",alt:""}})]),t._v(" "),s("h4",{attrs:{id:"三、table"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三、table"}},[t._v("#")]),t._v(" 三、table")]),t._v(" "),s("p",[t._v("表示这一行的数据是哪张表的数据")]),t._v(" "),s("h4",{attrs:{id:"四、type"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#四、type"}},[t._v("#")]),t._v(" 四、type")]),t._v(" "),s("p",[t._v("type 是代表 MySQL 使用了哪种索引类型，不同的索引类型的查询效率也是不一样的，type 大致有以下种类")]),t._v(" "),s("ul",[s("li",[t._v("system")]),t._v(" "),s("li",[t._v("const")]),t._v(" "),s("li",[t._v("eq_ref")]),t._v(" "),s("li",[t._v("ref")]),t._v(" "),s("li",[t._v("range")]),t._v(" "),s("li",[t._v("index")]),t._v(" "),s("li",[t._v("all\n"),s("img",{attrs:{src:"https://img-blog.csdnimg.cn/20210129215421411.png",alt:""}})])]),t._v(" "),s("p",[s("strong",[t._v("system")])]),t._v(" "),s("p",[t._v("表中只有一行记录，system 是 const 的特例，几乎不会出现这种情况，可以忽略不计")]),t._v(" "),s("p",[s("strong",[t._v("const")])]),t._v(" "),s("p",[t._v("将主键索引或者唯一索引放到 where 条件中查询，MySQL 可以将查询条件转变成一个常量，只匹配一行数据，索引一次就找到数据了\n"),s("img",{attrs:{src:"https://img-blog.csdnimg.cn/20210129215440848.png",alt:""}})]),t._v(" "),s("p",[s("strong",[t._v("eq_ref")])]),t._v(" "),s("p",[t._v("在多表查询中，如 T1 和 T2，T1 中的一行记录，在 T2 中也只能找到唯一的一行，说白了就是 T1 和 T2 关联查询的条件都是主键索引或者唯一索引，这样才能保证 T1 每一行记录只对应 T2 的一行记录")]),t._v(" "),s("p",[t._v("举个不太恰当的例子，EXPLAIN SELECT * from t1 , t2 where t1.id = t2.id")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdnimg.cn/20210129215455314.png",alt:""}})]),t._v(" "),s("h4",{attrs:{id:"ref"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ref"}},[t._v("#")]),t._v(" ref")]),t._v(" "),s("p",[t._v("不是主键索引，也不是唯一索引，就是普通的索引，可能会返回多个符合条件的行。\n"),s("img",{attrs:{src:"https://img-blog.csdnimg.cn/20210129215512216.png",alt:""}})]),t._v(" "),s("p",[s("strong",[t._v("range")])]),t._v(" "),s("p",[t._v("体现在对某个索引进行区间范围检索，一般出现在 where 条件中的 between、and、<、>、in 等范围查找中。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdnimg.cn/20210129215535695.png",alt:""}})]),t._v(" "),s("p",[s("strong",[t._v("index")])]),t._v(" "),s("p",[t._v("将所有的索引树都遍历一遍，查找到符合条件的行。索引文件比数据文件还是要小很多，所以比不用索引全表扫描还是要快很多。")]),t._v(" "),s("p",[s("strong",[t._v("all")])]),t._v(" "),s("p",[t._v("没用到索引，单纯的将表数据全部都遍历一遍，查找到符合条件的数据")]),t._v(" "),s("h4",{attrs:{id:"五、possible-keys"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#五、possible-keys"}},[t._v("#")]),t._v(" 五、possible_keys")]),t._v(" "),s("p",[t._v("此次查询中涉及字段上若存在索引，则会被列出来，表示可能会用到的索引，但并不是实际上一定会用到的索引")]),t._v(" "),s("h4",{attrs:{id:"六、key"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#六、key"}},[t._v("#")]),t._v(" 六、key")]),t._v(" "),s("p",[t._v("此次查询中实际上用到的索引")]),t._v(" "),s("h4",{attrs:{id:"七、key-len"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#七、key-len"}},[t._v("#")]),t._v(" 七、key_len")]),t._v(" "),s("p",[t._v("表示索引中使用的字节数，通过该属性可以知道在查询中使用的索引长度，注意：这个长度是最大可能长度，并非实际使用长度，在不损失精确性的情况下，长度越短查询效率越高")]),t._v(" "),s("h4",{attrs:{id:"八、ref"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#八、ref"}},[t._v("#")]),t._v(" 八、ref")]),t._v(" "),s("p",[t._v("显示关联的字段。如果使用常数等值查询，则显示 const，如果是连接查询，则会显示关联的字段。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdnimg.cn/20210129215605789.png",alt:""}})]),t._v(" "),s("ul",[s("li",[s("p",[t._v("tb_emp 表为非唯一性索引扫描，实际使用的索引列为 idx_name，由于 tb_emp.name='rose'为一个常量，所以 ref=const。")])]),t._v(" "),s("li",[s("p",[t._v("tb_dept 为唯一索引扫描，从 sql 语句可以看出，实际使用了 PRIMARY 主键索引，ref=db01.tb_emp.deptid 表示关联了 db01 数据库中 tb_emp 表的 deptid 字段。")])])]),t._v(" "),s("h4",{attrs:{id:"九、rows"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#九、rows"}},[t._v("#")]),t._v(" 九、rows")]),t._v(" "),s("p",[t._v("根据表信息统计以及索引的使用情况，大致估算说要找到所需记录需要读取的行数，rows 越小越好")]),t._v(" "),s("h4",{attrs:{id:"十、extra"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#十、extra"}},[t._v("#")]),t._v(" 十、extra")]),t._v(" "),s("p",[t._v("不适合在其他列显示出来，但在优化时十分重要的信息")]),t._v(" "),s("p",[s("strong",[t._v("using  fileSort（重点优化）")])]),t._v(" "),s("p",[t._v('俗称 " 文件排序 " ，在数据量大的时候几乎是“九死一生”，在 order by 或者在 group by 排序的过程中，order by 的字段不是索引字段，或者 select 查询字段存在不是索引字段，或者 select 查询字段都是索引字段，但是 order by 字段和 select 索引字段的顺序不一致，都会导致 fileSort')]),t._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdnimg.cn/20210129215634801.png",alt:""}})]),t._v(" "),s("p",[s("strong",[t._v("using temporary（重点优化）")])]),t._v(" "),s("p",[t._v("使用了临时表保存中间结果，常见于 order by 和 group by 中。\n"),s("img",{attrs:{src:"https://img-blog.csdnimg.cn/20210129215654609.png",alt:""}})]),t._v(" "),s("p",[s("strong",[t._v("USING index（重点）")])]),t._v(" "),s("p",[t._v("表示相应的 select 操作中使用了覆盖索引（Coveing Index）,避免访问了表的数据行，效率不错！\n如果同时出现 using where，表明索引被用来执行索引键值的查找；如果没有同时出现 using where，表面索引用来读取数据而非执行查找动作。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdnimg.cn/20210129215712637.png",alt:""}})]),t._v(" "),s("p",[s("strong",[t._v("Using where")])]),t._v(" "),s("p",[t._v("表明使用了 where 过滤")]),t._v(" "),s("p",[s("strong",[t._v("using join buffer")])]),t._v(" "),s("p",[t._v("使用了连接缓存")]),t._v(" "),s("p",[s("strong",[t._v("impossible where")])]),t._v(" "),s("p",[t._v("where 子句的值总是 false，不能用来获取任何元组")]),t._v(" "),s("p",[s("strong",[t._v("select tables optimized away")])]),t._v(" "),s("p",[t._v("在没有 GROUPBY 子句的情况下，基于索引优化 MIN/MAX 操作或者\n对于 MyISAM 存储引擎优化 COUNT(*)操作，不必等到执行阶段再进行计算，\n查询执行计划生成的阶段即完成优化。")]),t._v(" "),s("h3",{attrs:{id:"_6-慢查询日志"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6-慢查询日志"}},[t._v("#")]),t._v(" 6.慢查询日志")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("慢查询日志是MySQL提供的一种日志记录，它用来记录查询响应时间超过阀值的SQL语句")])]),t._v(" "),s("li",[s("p",[t._v("这个时间阀值通过参数long_query_time设置，如果SQL语句查询时间大于这个值，则会被记录到慢查询日志中，这个值默认是10秒")])]),t._v(" "),s("li",[s("p",[t._v("MySQL默认不开启慢查询日志，在需要调优的时候可以手动开启，但是多少会对数据库性能有点影响")])])]),t._v(" "),s("p",[t._v("慢查询日志可能会数据量非常大，那么我们如何快速找到需要优化的SQL语句呢，这个神奇诞生了，它就是mysqldumpshow。")]),t._v(" "),s("p",[t._v("通过mysqldumpslow --help可知这个命令是由三部分组成：mysqldumpslow [日志查找选项] [日志文件存储位置]。")])])}),[],!1,null,null,null);_.default=r.exports}}]);