(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{423:function(e,v,t){"use strict";t.r(v);var r=t(21),s=Object(r.a)({},(function(){var e=this,v=e.$createElement,t=e._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"redis三种过期策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis三种过期策略"}},[e._v("#")]),e._v(" Redis三种过期策略")]),e._v(" "),t("h3",{attrs:{id:"定时过期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#定时过期"}},[e._v("#")]),e._v(" 定时过期")]),e._v(" "),t("p",[e._v("每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即对key进行清除。该策略可以立即清除过期的数据，对内存很友好；但是"),t("strong",[e._v("会占用大量的CPU资源去处理过期的数据")]),e._v("，从而影响缓存的响应时间和吞吐量。")]),e._v(" "),t("h3",{attrs:{id:"惰性过期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#惰性过期"}},[e._v("#")]),e._v(" 惰性过期")]),e._v(" "),t("p",[e._v("只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却"),t("strong",[e._v("对内存非常不友好")]),e._v("。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。")]),e._v(" "),t("h3",{attrs:{id:"定期过期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#定期过期"}},[e._v("#")]),e._v(" 定期过期")]),e._v(" "),t("p",[e._v("每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源"),t("strong",[e._v("达到最优")]),e._v("的平衡效果。")]),e._v(" "),t("p",[e._v("expires字典会保存所有设置了过期时间的key的过期时间数据，其中 key 是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。")]),e._v(" "),t("h3",{attrs:{id:"默认策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#默认策略"}},[e._v("#")]),e._v(" 默认策略")]),e._v(" "),t("p",[e._v("Redis采用的过期策略："),t("code",[e._v("惰性删除")]),e._v(" + "),t("code",[e._v("定期删除")]),e._v("。memcached采用的过期策略："),t("code",[e._v("惰性删除")]),e._v("。")]),e._v(" "),t("h2",{attrs:{id:"redis-6种内存淘汰策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis-6种内存淘汰策略"}},[e._v("#")]),e._v(" Redis 6种内存淘汰策略")]),e._v(" "),t("p",[e._v("内存淘汰策略是指在Redis的用于缓存的"),t("strong",[e._v("内存不足时，怎么处理需要新写入且需要申请额外空间的数据")])]),e._v(" "),t("blockquote",[t("p",[e._v("过期策略指的是如何让key过期（此时内存可能有很多），而淘汰就是当我们内存不够时淘汰哪些数据（此时key可能并没有过期）")])]),e._v(" "),t("ol",[t("li",[e._v("volatile-lru（"),t("strong",[e._v("常考")]),e._v("）：从已设置过期时间的数据集（server.db[i].expires）中挑选"),t("strong",[e._v("最近最少使用")]),e._v("的数据淘汰")]),e._v(" "),t("li",[e._v("volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选"),t("strong",[e._v("将要过期")]),e._v("的数据淘汰")]),e._v(" "),t("li",[e._v("volatile-random：从已设置过期时间的数据集（server.db[i].expires）中"),t("strong",[e._v("任意选择")]),e._v("数据淘汰")]),e._v(" "),t("li",[e._v("allkeys-lru：从数据集（server.db[i].dict）中挑选"),t("strong",[e._v("最近最少使用")]),e._v("的数据淘汰")]),e._v(" "),t("li",[e._v("allkeys-random：从数据集（server.db[i].dict）中"),t("strong",[e._v("任意选择数")]),e._v("据淘汰")]),e._v(" "),t("li",[e._v("no-enviction（驱逐）：禁止驱逐数据，"),t("strong",[e._v("不删除")]),e._v("的意思。")])])])}),[],!1,null,null,null);v.default=s.exports}}]);