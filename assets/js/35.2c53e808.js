(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{442:function(_,v,t){"use strict";t.r(v);var a=t(21),s=Object(a.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h3",{attrs:{id:"tcp三次握手"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp三次握手"}},[_._v("#")]),_._v(" TCP三次握手")]),_._v(" "),t("ul",[t("li",[_._v("一开始，客户端和服务端都处于 "),t("code",[_._v("CLOSED")]),_._v(" 状态。先是服务端主动监听某个端口，处于 "),t("code",[_._v("LISTEN")]),_._v(" 状态。")]),_._v(" "),t("li",[_._v("然后客户端主动发起连接 "),t("code",[_._v("SYN")]),_._v("，之后处于 "),t("code",[_._v("SYN-SENT")]),_._v(" 状态。")]),_._v(" "),t("li",[_._v("服务端收到发起的连接，返回 "),t("code",[_._v("SYN")]),_._v("，并且 "),t("code",[_._v("ACK")]),_._v(" 客户端的 "),t("code",[_._v("SYN")]),_._v("，之后处于 "),t("code",[_._v("SYN-RCVD")]),_._v(" 状态。")]),_._v(" "),t("li",[_._v("客户端收到服务端发送的 "),t("code",[_._v("SYN")]),_._v(" 和 "),t("code",[_._v("ACK")]),_._v(" 之后，发送 "),t("code",[_._v("ACK")]),_._v(" 的 "),t("code",[_._v("ACK")]),_._v("，之后处于 "),t("code",[_._v("ESTABLISHED")]),_._v(" 状态，因为它一发一收成功了。")]),_._v(" "),t("li",[_._v("服务端收到 "),t("code",[_._v("ACK")]),_._v(" 的 "),t("code",[_._v("ACK")]),_._v(" 之后，处于 "),t("code",[_._v("ESTABLISHED")]),_._v(" 状态，因为它也一发一收了。")])]),_._v(" "),t("p",[_._v("所以三次握手目的是"),t("strong",[_._v("保证双方都有发送和接收的能力")]),_._v("。")]),_._v(" "),t("h3",{attrs:{id:"tcp可以建立两次握手嘛"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp可以建立两次握手嘛"}},[_._v("#")]),_._v(" TCP可以建立两次握手嘛")]),_._v(" "),t("p",[_._v("不可以。有两个原因：首先，可能会出现"),t("strong",[_._v("已失效的连接请求报文段又传到了服务器端")]),_._v("。")]),_._v(" "),t("p",[_._v("其次，两次握手无法保证Client正确接收第二次握手的报文（Server无法确认Client是否收到），也无法保证Client和Server之间成功互换初始序列号")]),_._v(" "),t("h3",{attrs:{id:"第三次握手中-如果客户端的ack未送达服务器-会怎样"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第三次握手中-如果客户端的ack未送达服务器-会怎样"}},[_._v("#")]),_._v(" 第三次握手中，如果客户端的ACK未送达服务器，会怎样？")]),_._v(" "),t("p",[_._v("Server端： 由于Server没有收到ACK确认，因此会重发之前的SYN+ACK（默认重发五次，之后自动关闭连接进入CLOSED状态），Client收到后会重新传ACK给Server。")]),_._v(" "),t("p",[_._v("Client端，两种情况：")]),_._v(" "),t("ol",[t("li",[_._v("在Server进行超时重发的过程中，如果Client向服务器发送数据，数据头部的ACK是为1的，所以服务器收到数据之后会读取 ACK number，进入 establish 状态")]),_._v(" "),t("li",[_._v("在Server进入CLOSED状态之后，如果Client向服务器发送数据，服务器会以RST包应答")])]),_._v(" "),t("h3",{attrs:{id:"如果已经建立了连接-但客户端出现了故障怎么办"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如果已经建立了连接-但客户端出现了故障怎么办"}},[_._v("#")]),_._v(" 如果已经建立了连接，但客户端出现了故障怎么办？")]),_._v(" "),t("p",[_._v("服务器每收到一次客户端的请求后都会重新复位一个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接")]),_._v(" "),t("h3",{attrs:{id:"什么是初始序列号"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是初始序列号"}},[_._v("#")]),_._v(" 什么是初始序列号")]),_._v(" "),t("p",[_._v("TCP连接的一方A，随机选择一个32位的序列号（Sequence Number）作为发送数据的初始序列号（Initial Sequence Number，ISN），比如为1000，以该序列号为原点，对要传送的数据进行编号：1001、1002...三次握手时，把这个初始序列号传送给另一方B，以便在传输数据时，B可以确认什么样的数据编号是合法的；同时在进行数据传输时，A还可以确认B收到的每一个字节，如果A收到了B的确认编号（acknowledge number）是2001，就说明编号为1001-2000的数据已经被B成功接受。")]),_._v(" "),t("h3",{attrs:{id:"为什么不能把服务器发送的ack和fin合并起来-变成三次挥手-close-wait状态意义是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么不能把服务器发送的ack和fin合并起来-变成三次挥手-close-wait状态意义是什么"}},[_._v("#")]),_._v(" 为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手（CLOSE_WAIT状态意义是什么）？")]),_._v(" "),t("p",[_._v("因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复ACK，表示接收到了断开连接的请求。等到数据发完之后再发FIN，断开服务器到客户端的数据传送。")]),_._v(" "),t("h3",{attrs:{id:"客户端time-wait状态的意义是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#客户端time-wait状态的意义是什么"}},[_._v("#")]),_._v(" 客户端TIME_WAIT状态的意义是什么？")]),_._v(" "),t("p",[_._v("网络情况不好时，如果主动方无TIME_WAIT等待，关闭前个连接后，主动方与被动方又建立起新的TCP连接，这时被动方重传或延时过来的FIN包过来后会直接影响新的TCP连接；")]),_._v(" "),t("p",[_._v("第四次挥手时，客户端发送给服务器的ACK有可能丢失，TIME_WAIT状态就是用来重发可能丢失的ACK报文。如果Server没有收到ACK，就会重发FIN，如果Client在2*MSL的时间内收到了FIN，就会重新发送ACK并再次等待2MSL，防止Server没有收到ACK而不断重发FIN。")]),_._v(" "),t("p",[_._v("MSL(Maximum Segment Lifetime)，指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接")]),_._v(" "),t("h3",{attrs:{id:"time-wait-和-close-wait-详解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#time-wait-和-close-wait-详解"}},[_._v("#")]),_._v(" TIME-WAIT 和 CLOSE-WAIT 详解")]),_._v(" "),t("p",[_._v("TIME_WAIT 是主动关闭链接时形成的，等待2MSL时间，约4分钟。主要是防止最后一个ACK丢失。 由于TIME_WAIT 的时间会非常长，因此server端应尽量减少主动关闭连接")]),_._v(" "),t("p",[_._v("一些"),t("code",[_._v("爬虫服务器")]),_._v("或者"),t("code",[_._v("WEB服务器")]),_._v("上经常会遇到这个问题，对于"),t("code",[_._v("爬虫服务器")]),_._v("来说他本身就是“客户端”，在完成一个爬取任务之后，他就会发起主动关闭连接，从而进入"),t("code",[_._v("TIME_WAIT")]),_._v("的状态")]),_._v(" "),t("blockquote",[t("p",[_._v("为什么要这么长时间呢？")]),_._v(" "),t("ol",[t("li",[_._v("防止上一次连接中的包，迷路后重新出现，影响新连接（经过2MSL，上一次连接中所有的重复包都会消失）")]),_._v(" "),t("li",[_._v("可靠的关闭"),t("code",[_._v("TCP")]),_._v("连接。在主动关闭方发送的最后一个"),t("code",[_._v("ack(fin)")]),_._v("，有可能丢失，这时被动方会重新发"),t("code",[_._v("fin")]),_._v(", 如果这时主动方处于"),t("code",[_._v("CLOSED")]),_._v("状态 ，就会响应"),t("code",[_._v("rst")]),_._v("而不是"),t("code",[_._v("ack")]),_._v("。所以主动方要处于"),t("code",[_._v("TIME_WAIT")]),_._v("状态，而不能是"),t("code",[_._v("CLOSED")]),_._v("。另外这么设计"),t("code",[_._v("TIME_WAIT")]),_._v("会定时的回收资源，并不会占用很大资源的，除非短时间内接受大量请求或者受到攻击。")])])]),_._v(" "),t("p",[_._v("这东西可以通过修改配置文件来解决")]),_._v(" "),t("p",[_._v("CLOSE_WAIT是被动关闭连接是形成的。就是在对方关闭连接之后服务器程序自己没有进一步发出"),t("code",[_._v("ack")]),_._v("信号。根据TCP状态机，服务器端收到客户端发送的FIN，则按照TCP实现发送ACK，因此进入CLOSE_WAIT状态。但如果服务器端不执行close()，就不能由CLOSE_WAIT迁移到LAST_ACK，则系统中会存在很多CLOSE_WAIT状态的连接。此时，可能是系统忙于处理读、写操作，而未将已收到FIN的连接，进行close。此时，recv/read已收到FIN的连接socket，会返回0。")]),_._v(" "),t("p",[_._v("因为linux分配给一个用户的文件句柄是有限的，而TIME_WAIT和CLOSE_WAIT两种状态如果一直被保持，那么意味着对应数目的通道就一直被占着，而且是“占着茅坑不使劲”，一旦达到句柄数上限，新的请求就无法被处理了，接着就是大量Too Many Open Files异常，Tomcat崩溃")]),_._v(" "),t("h3",{attrs:{id:"大量的time-wait是什么原因"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#大量的time-wait是什么原因"}},[_._v("#")]),_._v(" 大量的time-wait是什么原因？")]),_._v(" "),t("p",[_._v("在"),t("strong",[_._v("高并发短连接")]),_._v("的TCP服务器上，当服务器处理完请求后立刻按照主动正常关闭连接这个场景下，会出现大量socket处于TIMEWAIT状态。如果客户端的并发量持续很高，此时部分客户端就会显示连接不上")]),_._v(" "),t("h3",{attrs:{id:"tcp和udp的包头"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp和udp的包头"}},[_._v("#")]),_._v(" TCP和UDP的包头")]),_._v(" "),t("p",[_._v("TCP的包头如下")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://img.xiaoyou66.com/2021/04/12/d78af0e9db583.png",alt:"image.png"}})]),_._v(" "),t("p",[_._v("UDP的包头如下")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://img.xiaoyou66.com/2021/04/12/1fb36ddba1a4e.png",alt:"image.png"}})]),_._v(" "),t("p",[_._v("IP报文格式如下")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://img.xiaoyou66.com/2021/04/12/d88201aa4266f.png",alt:"image.png"}})]),_._v(" "),t("h3",{attrs:{id:"tcp流量控制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp流量控制"}},[_._v("#")]),_._v(" TCP流量控制")]),_._v(" "),t("p",[_._v("使用滑动窗口协议实现。流量控制是为了控制发送方发送速率，保证接收方来得及接收。")]),_._v(" "),t("p",[_._v("接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。")]),_._v(" "),t("p",[t("strong",[_._v("零窗口")]),_._v("：将窗口字段设置为 0，这个时候就叫零窗口。发送方必须暂停发送数据，但是会启动一个持续计时器(persistence timer)，到期后发送一个大小为1字节的探测数据包，以查看接收窗口状态。如果接收方能够接收数据，就会在返回的报文中更新接收窗口大小，恢复数据传送。")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://img.xiaoyou66.com/images/2020/11/22/V4ldH.png",alt:"img"}})]),_._v(" "),t("h3",{attrs:{id:"滑动窗口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#滑动窗口"}},[_._v("#")]),_._v(" 滑动窗口")]),_._v(" "),t("p",[_._v("在TCP协议中，发送算法各有一个窗口，"),t("strong",[_._v("接收方")]),_._v("会在"),t("strong",[_._v("确认报文")]),_._v("中通过窗口字段来告诉发送方，发送方根据这个值和其它信息设置自己的窗口大小")]),_._v(" "),t("p",[t("strong",[_._v("发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收")]),_._v("。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。")]),_._v(" "),t("p",[t("strong",[_._v("接收窗口只会对窗口内最后一个按序到达的字节进行确认")]),_._v("，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {32, 33} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://img.xiaoyou66.com/2021/03/22/0c59d6f382fa4.jpg",alt:"img"}})]),_._v(" "),t("p",[t("img",{attrs:{src:"https://img.xiaoyou66.com/2021/03/22/5357b4735139f.jpg",alt:"img"}})]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("发送方接收到了对方发来的报文 ack = 33, win = 10，知道对方收到了 33 号前的数据")]),_._v("，现在期望接收 [33, 43) 号数据。发送方连续发送了 4 个报文段假设为 A, B, C, D, 分别携带 [33, 35), [35, 36), [36, 38), [38, 41) 号数据。")]),_._v(" "),t("li",[_._v("接收方接收到了报文段 A, C，但是没收到 B 和 D，也就是只收到了 [33, 35) 和 [36, 38) 号数据。接收方发送回对报文段 A 的确认：ack = 35, win = 10。")]),_._v(" "),t("li",[_._v("发送方收到了 ack = 35, win = 10，对方期望接收 [35, 45) 号数据。发送方向法B，C，D然后发送了一个报文段 E，它携带了 [41, 44) 号数据。")]),_._v(" "),t("li",[_._v("需要注意的是，"),t("strong",[_._v("接收方接收 tcp 报文的顺序是不确定的，并非是一定先收到 35 再收到 36，也可能是先收到 36，37，再收到 35")])])]),_._v(" "),t("h3",{attrs:{id:"tcp拥塞控制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp拥塞控制"}},[_._v("#")]),_._v(" TCP拥塞控制")]),_._v(" "),t("h3",{attrs:{id:"什么情况下会出现拥塞"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么情况下会出现拥塞"}},[_._v("#")]),_._v(" 什么情况下会出现拥塞")]),_._v(" "),t("ul",[t("li",[_._v("在某段时间，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏——产生拥塞(congestion)。")]),_._v(" "),t("li",[_._v("出现资源拥塞的条件：对资源需求的总和 > 可用资源")]),_._v(" "),t("li",[_._v("若网络中有许多资源同时产生拥塞，网络的性能就要明显变坏，整个网络的吞吐量将随输入负荷的增大而下降。")])]),_._v(" "),t("p",[_._v("如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。"),t("strong",[_._v("流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。")])]),_._v(" "),t("h3",{attrs:{id:"拥塞控制的四种算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#拥塞控制的四种算法"}},[_._v("#")]),_._v(" 拥塞控制的四种算法")]),_._v(" "),t("p",[_._v("慢开始、拥塞避免、快重传、快恢复")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://img.xiaoyou66.com/2021/03/22/1c571b76b8ff9.jpg",alt:"img"}})]),_._v(" "),t("h3",{attrs:{id:"慢开始和拥塞避免"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#慢开始和拥塞避免"}},[_._v("#")]),_._v(" 慢开始和拥塞避免")]),_._v(" "),t("ol",[t("li",[_._v("发送的最初执行慢开始，令 cwnd=1，发送方只能发送 1 个报文段； "),t("strong",[_._v("当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 ...")])]),_._v(" "),t("li",[_._v("因为每次都是加倍，所以可能增长很快，我们可以 "),t("strong",[_._v("设置一个慢启动阈值 ssthresh，当 cwnd >= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。")])]),_._v(" "),t("li",[t("strong",[_._v("如果出现了超时，则令 ssthresh = cwnd/2，然后重新执行慢开始。")])])]),_._v(" "),t("h3",{attrs:{id:"快重传与快恢复"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#快重传与快恢复"}},[_._v("#")]),_._v(" 快重传与快恢复")]),_._v(" "),t("p",[_._v("在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。")]),_._v(" "),t("p",[_._v("在发送方，如果收到 "),t("strong",[_._v("三个重复确认")]),_._v(" ，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。")]),_._v(" "),t("p",[_._v("在这种情况下，"),t("strong",[_._v("只是丢失个别报文段，而不是网络拥塞。因此执行快恢复")]),_._v("，令 ssthresh = cwnd/2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。")]),_._v(" "),t("p",[t("strong",[_._v("总结：")]),_._v(" 简单点来说我们收到三个重复的报文确认时，我们执行快重传，重传丢失的报文。然后我们令ssthresh = cwnd/2 ，cwnd = ssthresh这个过程就是快恢复。")]),_._v(" "),t("p",[t("img",{attrs:{src:"https://img.xiaoyou66.com/2021/03/22/f372a27a4e858.jpg",alt:"img"}})]),_._v(" "),t("h3",{attrs:{id:"如何确定发送窗口上限"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何确定发送窗口上限"}},[_._v("#")]),_._v(" 如何确定发送窗口上限")]),_._v(" "),t("p",[t("strong",[_._v("发送方的发送窗口的上限值应当取为接收方窗口 rwnd 和拥塞窗口 cwnd 这两个变量中较小的一个")]),_._v("，即应按以下公式确定：发送窗口的上限值 = Min {rwnd, cwnd}")]),_._v(" "),t("ul",[t("li",[_._v("当 rwnd < cwnd 时，是接收方的接收能力限制发送窗口的最大值。")]),_._v(" "),t("li",[_._v("当 cwnd < rwnd 时，则是网络的拥塞限制发送窗口的最大值。")])]),_._v(" "),t("h3",{attrs:{id:"流量控制和拥塞控制区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#流量控制和拥塞控制区别"}},[_._v("#")]),_._v(" 流量控制和拥塞控制区别")]),_._v(" "),t("ul",[t("li",[_._v("拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。")]),_._v(" "),t("li",[_._v("拥塞控制是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。")]),_._v(" "),t("li",[_._v("流量控制往往指在给定的发送端和接收端之间的点对点通信量的控制。")]),_._v(" "),t("li",[_._v("流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。")]),_._v(" "),t("li",[_._v("流量控制属于通信双方协商；拥塞控制涉及通信链路全局。")]),_._v(" "),t("li",[_._v("流量控制需要通信双方各维护一个发送窗、一个接收窗，对任意一方，接收窗大小由自身决定，发送窗大小由接收方响应的TCP报文段中窗口值确定；拥塞控制的拥塞窗口大小变化由试探性发送一定数据量数据探查网络状况后而自适应调整。")]),_._v(" "),t("li",[_._v("实际最终发送窗口 = min{流控发送窗口，拥塞窗口}")])]),_._v(" "),t("h3",{attrs:{id:"tcp和udp的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp和udp的区别"}},[_._v("#")]),_._v(" TCP和UDP的区别")]),_._v(" "),t("ol",[t("li",[_._v("TCP是面向连接的，UDP是无连接的（无连接就是UDP发送数据之前不需要建立连接）")]),_._v(" "),t("li",[_._v("TCP是可靠的，UDP是不可靠的（不可靠就是UDP接收方收到报文后，不需要给出任何确认）")]),_._v(" "),t("li",[_._v("TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多；")]),_._v(" "),t("li",[_._v("TCP是面向字节流的，UDP是面向报文的；（面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送，而UDP一个报文只能一次发完。）")]),_._v(" "),t("li",[_._v("TCP有拥塞控制机制，UDP没有。网络出现的拥塞不会使源主机的发送速率降低，这对某些实时应用是很重要的，比如媒体通信，游戏；")]),_._v(" "),t("li",[_._v("TCP首部开销（20字节）比UDP首部开销（8字节）要大")]),_._v(" "),t("li",[_._v("UDP 的主机不需要维持复杂的连接状态表")])]),_._v(" "),t("h3",{attrs:{id:"tcp如何保证传输可靠"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp如何保证传输可靠"}},[_._v("#")]),_._v(" TCP如何保证传输可靠")]),_._v(" "),t("ol",[t("li",[_._v("数据包校验")]),_._v(" "),t("li",[_._v("对失序数据包重新排序（TCP报文具有序列号）")]),_._v(" "),t("li",[_._v("丢弃重复数据")]),_._v(" "),t("li",[_._v("应答机制：接收方收到数据之后，会发送一个确认（通常延迟几分之一秒）；")]),_._v(" "),t("li",[_._v("超时重发：发送方发出数据之后，启动一个定时器，超时未收到接收方的确认，则重新发送这个数据；")]),_._v(" "),t("li",[_._v("流量控制：确保接收端能够接收发送方的数据而不会缓冲区溢出")])]),_._v(" "),t("h3",{attrs:{id:"tcp的粘包与拆包"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp的粘包与拆包"}},[_._v("#")]),_._v(" TCP的粘包与拆包")]),_._v(" "),t("p",[_._v("1、要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包。")]),_._v(" "),t("p",[_._v("2、待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。")]),_._v(" "),t("p",[_._v("3、要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包。")]),_._v(" "),t("p",[_._v("4、接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。")]),_._v(" "),t("p",[t("strong",[_._v("粘包、拆包解决办法")])]),_._v(" "),t("p",[_._v("通过以上分析，我们清楚了粘包或拆包发生的原因，那么如何解决这个问题呢？解决问题的关键在于如何给每个数据包添加边界信息，常用的方法有如下几个：")]),_._v(" "),t("p",[_._v("1、发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。")]),_._v(" "),t("p",[_._v("2、发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。")]),_._v(" "),t("p",[_._v("3、可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开")]),_._v(" "),t("h3",{attrs:{id:"socket有几个队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#socket有几个队列"}},[_._v("#")]),_._v(" socket有几个队列")]),_._v(" "),t("p",[_._v("TCP三次握手建立连接的过程中，内核通常会为每一个LISTEN状态的Socket维护两个队列：")]),_._v(" "),t("ul",[t("li",[_._v("SYN队列（半连接队列）：这些连接已经接到客户端SYN；")]),_._v(" "),t("li",[_._v("ACCEPT队列（全连接队列）：这些连接已经接到客户端的ACK，完成了三次握手，等待被accept系统调用取走")])])])}),[],!1,null,null,null);v.default=s.exports}}]);