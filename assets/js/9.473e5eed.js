(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{416:function(t,_,a){"use strict";a.r(_);var v=a(21),s=Object(v.a)({},(function(){var t=this,_=t.$createElement,a=t._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[a("img",{attrs:{src:"https://img-blog.csdnimg.cn/20210313154821451.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDc3NzY2OQ==,size_16,color_FFFFFF,t_70#pic_center",alt:"在这里插入图片描述"}})]),t._v(" "),a("h2",{attrs:{id:"常见问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常见问题"}},[t._v("#")]),t._v(" 常见问题")]),t._v(" "),a("h3",{attrs:{id:"数据一致性怎么保证"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据一致性怎么保证"}},[t._v("#")]),t._v(" 数据一致性怎么保证？")]),t._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/iaZesVjgjQ8iaXINSXnYhulC00sAibh2DdiapP2szHyZ28U8tWNQ6wMhC43ns8VOROnRLPepjExPnVLq1hKRYgicv0g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}}),t._v(" "),a("h4",{attrs:{id:"先删缓存-再更新数据库"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#先删缓存-再更新数据库"}},[t._v("#")]),t._v(" 先删缓存，再更新数据库")]),t._v(" "),a("p",[t._v("先删除缓存，数据库还没有更新成功，此时如果读取缓存，缓存不存在，去数据库中读取到的是旧值，缓存不一致发生。")]),t._v(" "),a("p",[a("strong",[t._v("解决方案")])]),t._v(" "),a("p",[t._v("延时双删的方案的思路是，为了避免更新数据库的时候，其他线程从缓存中读取不到数据，就在更新完数据库之后，再sleep一段时间，然后再次删除缓存。")]),t._v(" "),a("p",[t._v("sleep的时间要对业务读写缓存的时间做出评估，sleep时间大于读写缓存的时间即可。")]),t._v(" "),a("p",[t._v("流程如下：")]),t._v(" "),a("ol",[a("li",[t._v("线程1删除缓存，然后去更新数据库")]),t._v(" "),a("li",[t._v("线程2来读缓存，发现缓存已经被删除，所以直接从数据库中读取，这时候由于线程1还没有更新完成，所以读到的是旧值，然后把旧值写入缓存")]),t._v(" "),a("li",[t._v("线程1，根据估算的时间，sleep，由于sleep的时间大于线程2读数据+写缓存的时间，所以缓存被再次删除")]),t._v(" "),a("li",[t._v("如果还有其他线程来读取缓存的话，就会再次从数据库中读取到最新值")])]),t._v(" "),a("h4",{attrs:{id:"先更新数据库-再删除缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#先更新数据库-再删除缓存"}},[t._v("#")]),t._v(" 先更新数据库，再删除缓存")]),t._v(" "),a("p",[t._v("先更新数据库，成功后往消息队列发消息，消费到消息后再删除缓存，借助消息队列的重试机制来实现，达到最终一致性的效果。")]),t._v(" "),a("p",[t._v("这个解决方案其实问题更多。")]),t._v(" "),a("ol",[a("li",[t._v("引入消息中间件之后，问题更复杂了，怎么保证消息不丢失更麻烦")]),t._v(" "),a("li",[t._v("就算更新数据库和删除缓存都没有发生问题，消息的延迟也会带来短暂的不一致性，不过这个延迟相对来说还是可以接受的")])]),t._v(" "),a("p",[a("strong",[t._v("为了解决缓存一致性的问题单独引入一个消息队列，太复杂了。")])]),t._v(" "),a("p",[t._v("其实，一般大公司本身都会有监听binlog消息的消息队列存在，主要是为了做一些核对的工作。")]),t._v(" "),a("p",[t._v("这样，我们可以借助监听binlog的消息队列来做删除缓存的操作。这样做的好处是，不用你自己引入，侵入到你的业务代码中，中间件帮你做了解耦，同时，中间件的这个东西本身就保证了高可用。")]),t._v(" "),a("p",[t._v("当然，这样消息延迟的问题依然存在，但是相比单纯引入消息队列的做法更好一点。")]),t._v(" "),a("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://mmbiz.qpic.cn/mmbiz_png/iaZesVjgjQ8iaXINSXnYhulC00sAibh2DdiaWwljvuWy6QyibOkDA0ibLd68uyD8r4iaicjtX2KNuIsRITsdKXXpOHOaibw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1",alt:"图片"}}),t._v(" "),a("h4",{attrs:{id:"设置缓存过期时间"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#设置缓存过期时间"}},[t._v("#")]),t._v(" 设置缓存过期时间")]),t._v(" "),a("p",[t._v("每次放入缓存的时候，设置一个过期时间，比如5分钟，以后的操作只修改数据库，不操作缓存，等待缓存超时后从数据库重新读取。")]),t._v(" "),a("p",[t._v("如果对于一致性要求不是很高的情况，可以采用这种方案。")]),t._v(" "),a("p",[t._v("这个方案还会有另外一个问题，就是如果数据更新的特别频繁，不一致性的问题就很大了。")]),t._v(" "),a("p",[t._v("在实际生产中，我们有一些活动的缓存数据是使用这种方式处理的。")]),t._v(" "),a("p",[t._v("因为活动并不频繁发生改变，而且对于活动来说，短暂的不一致性并不会有什么大的问题。")]),t._v(" "),a("h4",{attrs:{id:"首先-我们要明确一点-缓存不是更新-而应该是删除。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#首先-我们要明确一点-缓存不是更新-而应该是删除。"}},[t._v("#")]),t._v(" 首先，我们要明确一点，缓存不是更新，而应该是删除。")]),t._v(" "),a("p",[t._v("删除缓存有两种方式：")]),t._v(" "),a("ol",[a("li",[t._v("先删除缓存，再更新数据库。解决方案是使用延迟双删。")]),t._v(" "),a("li",[t._v("先更新数据库，再删除缓存。解决方案是消息队列或者其他binlog同步，引入消息队列会带来更多的问题，并不推荐直接使用。")])]),t._v(" "),a("p",[t._v("针对缓存一致性要求不是很高的场景，那么只通过设置超时时间就可以了。")]),t._v(" "),a("p",[t._v("参考:"),a("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&mid=2453149368&idx=2&sn=75d6ba3523303d9cac1f1c367209ef89&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[t._v("敖丙"),a("OutboundLink")],1)]),t._v(" "),a("h3",{attrs:{id:"事务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事务"}},[t._v("#")]),t._v(" 事务")]),t._v(" "),a("p",[t._v("Redis支持事务，通过 MULTI（事务开始）DISCARD （事务取消）EXEC （执行事务）和 WATCH （监听key，当key被修改时会打断当前事务）四个命令来实现事务功能")]),t._v(" "),a("h3",{attrs:{id:"执行的三个阶段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#执行的三个阶段"}},[t._v("#")]),t._v(" 执行的三个阶段")]),t._v(" "),a("ol",[a("li",[t._v("开启事务（multi）")]),t._v(" "),a("li",[t._v("命令入队（业务操作）")]),t._v(" "),a("li",[t._v("执行事务（exec）或取消事务（discard）")])]),t._v(" "),a("h3",{attrs:{id:"特点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#特点"}},[t._v("#")]),t._v(" 特点")]),t._v(" "),a("ol",[a("li",[t._v("redis事务就是一次性、顺序性、排他性的执行一个队列中的"),a("strong",[t._v("一系列命令")]),t._v("。")]),t._v(" "),a("li",[t._v("Redis事务失败时不支持回滚，而是会继续执行剩下的命令")])])])}),[],!1,null,null,null);_.default=s.exports}}]);