(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{431:function(a,t,s){"use strict";s.r(t);var e=s(21),v=Object(e.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h2",{attrs:{id:"mybatis-是如何进行分页的-分页插件的原理是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mybatis-是如何进行分页的-分页插件的原理是什么"}},[a._v("#")]),a._v(" MyBatis 是如何进行分页的？分页插件的原理是什么？")]),a._v(" "),s("p",[a._v("MyBatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的"),s("code",[a._v("内存分页")]),a._v("，而非物理分页，可以在 sql 内直接书写带有物理分页的参数来完成物理分页功能，也可以使用"),s("code",[a._v("分页插件来完成物理分页")]),a._v("。")]),a._v(" "),s("p",[a._v("分页插件的基本原理是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 sql，然后重写 sql，根据 dialect 方言，添加对应的物理分页语句和物理分页参数")]),a._v(" "),s("h2",{attrs:{id:"和-的区别是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#和-的区别是什么"}},[a._v("#")]),a._v(" #{}和${}的区别是什么？")]),a._v(" "),s("ul",[s("li",[s("code",[a._v("${}")]),a._v("是 Properties 文件中的变量占位符，它可以用于标签属性值和 sql 内部，属于静态文本替换，比如${driver}会被静态替换为"),s("code",[a._v("com.mysql.jdbc.Driver")]),a._v("。")]),a._v(" "),s("li",[s("code",[a._v("#{}")]),a._v("是 sql 的参数占位符，MyBatis 会将 sql 中的"),s("code",[a._v("#{}")]),a._v("替换为?号，在 sql 执行前会使用 PreparedStatement 的参数设置方法，按序给 sql 的?号占位符设置参数值，比如 ps.setInt(0, parameterValue)，"),s("code",[a._v("#{item.name}")]),a._v(" 的取值方式为使用反射从参数对象中获取 item 对象的 name 属性值，相当于 "),s("code",[a._v("param.getItem().getName()")]),a._v("。")])]),a._v(" "),s("h2",{attrs:{id:"为什么说-mybatis-是半自动-orm-映射工具-它与全自动的区别在哪里"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么说-mybatis-是半自动-orm-映射工具-它与全自动的区别在哪里"}},[a._v("#")]),a._v(" 为什么说 MyBatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？")]),a._v(" "),s("p",[a._v("Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而 MyBatis 在查询关联对象或关联集合对象时，需要手动编写 sql 来完成，所以，称之为半自动 ORM 映射工具。")]),a._v(" "),s("p",[a._v("##解释下MyBatis面向Mapper编程工作原理？")]),a._v(" "),s("p",[a._v("Mapper接口是没有实现类的，当调用接口方法时，采用了JDK的动态代理，先从Configuration配置类MapperRegistry对象中获取mapper接口和对应的代理对象工厂信息（MapperProxyFactory），然后利用代理对象工厂MapperProxyFactory创建实际代理类（MapperProxy），最后在MapperProxy类中通过MapperMethod类对象内保存的中对应方法的信息，以及对应的sql语句的信息进行分析，最终确定对应的增强方法进行调用。")]),a._v(" "),s("h2",{attrs:{id:"一级缓存-二级缓存都解决了什么问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一级缓存-二级缓存都解决了什么问题"}},[a._v("#")]),a._v(" 一级缓存,二级缓存都解决了什么问题？")]),a._v(" "),s("h3",{attrs:{id:"一级缓存介绍"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一级缓存介绍"}},[a._v("#")]),a._v(" 一级缓存介绍")]),a._v(" "),s("p",[a._v("在应用运行过程中，我们有可能在一次数据库会话中，执行多次查询条件完全相同的SQL，MyBatis提供了一级缓存的方案优化这部分场景，如果是相同的SQL语句，会优先命中一级缓存，避免直接对数据库进行查询，提高性能。具体执行过程如下图所示。")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/6e38df6a.jpg",alt:"img"}})]),a._v(" "),s("p",[a._v("每个SqlSession中持有了Executor，每个Executor中有一个LocalCache。当用户发起查询时，MyBatis根据当前执行的语句生成"),s("code",[a._v("MappedStatement")]),a._v("，在Local Cache进行查询，如果缓存命中的话，直接返回结果给用户，如果缓存没有命中的话，查询数据库，结果写入"),s("code",[a._v("Local Cache")]),a._v("，最后返回结果给用户。")]),a._v(" "),s("h3",{attrs:{id:"总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[a._v("#")]),a._v(" 总结")]),a._v(" "),s("ol",[s("li",[a._v("MyBatis一级缓存的生命周期和SqlSession一致。")]),a._v(" "),s("li",[a._v("MyBatis一级缓存内部设计简单，只是一个没有容量限定的HashMap，在缓存的功能性上有所欠缺。")]),a._v(" "),s("li",[a._v("MyBatis的一级缓存最大范围是SqlSession内部，有多个SqlSession或者分布式的环境下，数据库写操作会引起脏数据，建议设定缓存级别为Statement。")])]),a._v(" "),s("h3",{attrs:{id:"二级缓存介绍"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二级缓存介绍"}},[a._v("#")]),a._v(" 二级缓存介绍")]),a._v(" "),s("p",[a._v("在上文中提到的一级缓存中，其最大的共享范围就是一个SqlSession内部，如果多个SqlSession之间需要共享缓存，则需要使用到二级缓存。开启二级缓存后，会使用CachingExecutor装饰Executor，进入一级缓存的查询流程前，先在CachingExecutor进行二级缓存的查询，具体的工作流程如下所示。")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://awps-assets.meituan.net/mit-x/blog-images-bundle-2018a/28399eba.png",alt:"img"}})]),a._v(" "),s("p",[a._v("二级缓存开启后，同一个namespace下的所有操作语句，都影响着同一个Cache，即二级缓存被多个SqlSession共享，是一个全局的变量。")]),a._v(" "),s("p",[a._v("当开启二级缓存后，数据的查询执行的流程就是 二级缓存 -> 一级缓存 -> 数据库。")]),a._v(" "),s("h3",{attrs:{id:"总结-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#总结-2"}},[a._v("#")]),a._v(" 总结")]),a._v(" "),s("ol",[s("li",[a._v("MyBatis的二级缓存相对于一级缓存来说，实现了"),s("code",[a._v("SqlSession")]),a._v("之间缓存数据的共享，同时粒度更加的细，能够到"),s("code",[a._v("namespace")]),a._v("级别，通过Cache接口实现类不同的组合，对Cache的可控性也更强。")]),a._v(" "),s("li",[a._v("MyBatis在多表查询时，极大可能会出现脏数据，有设计上的缺陷，安全使用二级缓存的条件比较苛刻。")]),a._v(" "),s("li",[a._v("在分布式环境下，由于默认的MyBatis Cache实现都是基于本地的，分布式环境下必然会出现读取到脏数据，需要使用集中式缓存将MyBatis的Cache接口实现，有一定的开发成本，直接使用Redis、Memcached等分布式缓存可能成本更低，安全性也更高。")])]),a._v(" "),s("h2",{attrs:{id:"mybatis中用到了哪些设计模式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mybatis中用到了哪些设计模式"}},[a._v("#")]),a._v(" Mybatis中用到了哪些设计模式")]),a._v(" "),s("p",[a._v("日志模块：代理模式、适配器模式")]),a._v(" "),s("p",[a._v("数据源模块：代理模式、工厂模式")]),a._v(" "),s("p",[a._v("缓存模块：装饰器模式")]),a._v(" "),s("p",[a._v("初始化阶段：建造者模式")]),a._v(" "),s("p",[a._v("代理阶段：策略模式")]),a._v(" "),s("p",[a._v("数据读写阶段：模板模式")]),a._v(" "),s("p",[a._v("插件化开发：责任链模式")]),a._v(" "),s("h2",{attrs:{id:"源码包功能模块图"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#源码包功能模块图"}},[a._v("#")]),a._v(" 源码包功能模块图")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdnimg.cn/20200830162428980.png",alt:""}})])])}),[],!1,null,null,null);t.default=v.exports}}]);